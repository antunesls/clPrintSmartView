#Include 'totvs.ch'
#Include "tlpp-core.th"
#Include "tlpp-rest.th"

//-------------------------------------------------------------------
// Namespace
//-------------------------------------------------------------------
Namespace PrintSmartView

//-------------------------------------------------------------------
/*/{Protheus.doc} clPrintSmartView
Classe para geração e download de relatórios SmartView de forma automatizada.
Permite gerar relatórios sem interface gráfica, ideal para uso em:
- Jobs programados
- Schedules
- Envio automático para impressoras
- Processamentos em background
- Integração com APIs

Configurações automáticas no construtor:
- URL: MV_PSVURL (padrão: http://localhost:7017)
- Usuário: MV_PSVUSER (padrão: admin)
- Senha: MV_PSVPASS (padrão: admin)
- Endpoint: /api/reports/v2/generate
- Header: Content-Type: application/json
- Cache de token: habilitado em MV_PSVTOKN

@type class
@author Lucas Souza - Insider Consulting
@since 28/11/2025
@version 1.0
@example
// Exemplo básico (usa configurações dos parâmetros)
oReport := clPrintSmartView():New()
oReport:SetReportId("uuid-do-relatorio")
cArquivo := oReport:GenerateReport({{"param1","valor"}}, {"pdf"}, .T.)

// Exemplo personalizado (sobrescreve padrões)
oReport := clPrintSmartView():New()
oReport:SetUrl("http://outro-servidor:8080")
oReport:SetCredentials("usuario", "senha")
oReport:SetReportId("uuid-do-relatorio")
cArquivo := oReport:GenerateReport({}, {"pdf"}, .T.)
/*/
//-------------------------------------------------------------------
Class clPrintSmartView

	// Propriedades públicas
	Public Data cEndpoint As Character
	Public Data aHeaders As Array
	Public Data cLastError As Character
	Public Data cTempPath As Character
	Public Data nTimeout As Numeric
	Public Data cToken As Character
	Public Data cReportId As Character
	Public Data cGenerationId As Character
	
	// Propriedades privadas
	Private Data cUrl As Character
	Private Data cUsername As Character
	Private Data cPassword As Character
	Private Data lUseParamCache As Logical
	Private Data cTokenExpiry As Character
	
	// Métodos públicos
	Public Method New()
	Public Method SetUrl(cUrl As Character) As Logical
	Public Method GetUrl() As Character
	Public Method SetEndpoint(cEndpoint As Character) As Logical
	Public Method AddHeader(cKey As Character, cValue As Character) As Logical
	Public Method SetTimeout(nSeconds As Numeric) As Logical
	Public Method SetCredentials(cUsername As Character, cPassword As Character) As Logical
	Public Method GetUsername() As Character
	Public Method Authenticate(lRememberUser As Logical) As Logical
	Public Method SetToken(cToken As Character) As Logical
	Public Method EnableTokenCache(lEnable As Logical) As Logical
	Public Method GetCachedToken() As Character
	Public Method EnsureAuthenticated() As Logical
	Public Method SetReportId(cReportId As Character) As Logical
	Public Method SetGenerationId(cGenerationId As Character) As Logical
	Public Method GenerateReport(aParameters As Array, aFormats As Array, lSaveFile As Logical, cFileName As Character) As Variant
	Public Method CheckReportStatus() As Character
	Public Method WaitAndDownloadReport(cFormat As Character, lSaveFile As Logical, cFileName As Character) As Variant
	Public Method DownloadReport(cFormat As Character, lSaveFile As Logical, cFileName As Character) As Variant
	Public Method GetRequest(lSaveFile As Logical, cFileName As Character) As Variant
	Public Method PostRequest(cJsonBody As Character) As Variant
	Public Method GetLastError() As Character
	Public Method SaveToTemp(cContent As Character, cFileName As Character) As Character
	Public Method ConvertToBase64(cContent As Character) As Character
	Public Method FileToBase64(cFilePath As Character) As Character
	Public Method SendFileAsBase64(cJsonBody As Character, cFilePath As Character) As Character

EndClass

//-------------------------------------------------------------------
/*/{Protheus.doc} New
Construtor da classe - carrega configurações automaticamente dos parâmetros
@type method
@return object, Instância da classe
@author Lucas Souza - Insider Consulting
@since 28/11/2025
@obs Carrega automaticamente:
- URL de MV_PSVURL (padrão: http://localhost:7017)
- Credenciais de MV_PSVUSER/MV_PSVPASS (padrão: admin/admin)
- Endpoint padrão: /api/reports/v2/generate
- Header Content-Type: application/json
- Cache de token habilitado (MV_PSVTOKN)
/*/
//-------------------------------------------------------------------
Method New() Class clPrintSmartView

	// Carrega configurações dos parâmetros
	::cUrl := SuperGetMV("MV_PSVURL", .F., "http://localhost:7017")
	::cUsername := SuperGetMV("MV_PSVUSER", .F., "admin")
	::cPassword := SuperGetMV("MV_PSVPASS", .F., "admin")
	
	::cEndpoint := "/api/reports/v2/generate"
	::aHeaders := {}
	::cLastError := ""
	::cTempPath := GetTempPath()
	::nTimeout := 120
	::cToken := ""
	::cReportId := ""
	::cGenerationId := ""
	::lUseParamCache := .T. // Habilita cache de token por padrão
	::cTokenExpiry := ""
	
	// Adiciona header padrão
	::AddHeader("Content-Type", "application/json")

Return Self

//-------------------------------------------------------------------
/*/{Protheus.doc} SetUrl
Define a URL base para as requisições
@type method
@param cUrl, character, URL base
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetUrl(cUrl As Character) As Logical Class clPrintSmartView
	::cUrl := cUrl
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GetUrl
Retorna a URL base configurada
@type method
@return character, URL base
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GetUrl() As Character Class clPrintSmartView
Return ::cUrl

//-------------------------------------------------------------------
/*/{Protheus.doc} SetEndpoint
Define o endpoint específico (padrão: /api/reports/v2/generate)
@type method
@param cEndpoint, character, Endpoint da API (opcional)
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetEndpoint(cEndpoint As Character) As Logical Class clPrintSmartView
	Default cEndpoint := "/api/reports/v2/generate"
	::cEndpoint := cEndpoint
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} AddHeader
Adiciona um header à requisição
@type method
@param cKey, character, Chave do header
@param cValue, character, Valor do header
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method AddHeader(cKey As Character, cValue As Character) As Logical Class clPrintSmartView
	aAdd(::aHeaders, {cKey, cValue})
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SetTimeout
Define o timeout da requisição
@type method
@param nSeconds, numeric, Timeout em segundos
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetTimeout(nSeconds As Numeric) As Logical Class clPrintSmartView
	::nTimeout := nSeconds
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SetCredentials
Define as credenciais de usuário e senha para autenticação
@type method
@param cUsername, character, Nome de usuário
@param cPassword, character, Senha
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetCredentials(cUsername As Character, cPassword As Character) As Logical Class clPrintSmartView
	::cUsername := cUsername
	::cPassword := cPassword
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GetUsername
Retorna o nome de usuário configurado
@type method
@return character, Nome de usuário
@author Lucas Souza - Insider Consulting
@since 28/11/2025
@obs A senha não possui método Get por questões de segurança
/*/
//-------------------------------------------------------------------
Method GetUsername() As Character Class clPrintSmartView
Return ::cUsername

//-------------------------------------------------------------------
/*/{Protheus.doc} Authenticate
Realiza autenticação e obtém token JWT
@type method
@param lRememberUser, logical, Se deve lembrar o usuário
@return logical, .T. se autenticou com sucesso
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method Authenticate(lRememberUser As Logical) As Logical Class clPrintSmartView
	
	Local oRestClient As Object
	//Local cFullUrl As Character
	Local cResponse As Character
	Local cBasicAuth As Character
	Local cCredentials As Character
	Local cJsonBody As Character
	Local oJson As Object
	Local aHeader As Array
	Local lSuccess := .F.
	
	aHeader := {}

	Default lRememberUser := .F.

	::cLastError := ""

	// Valida credenciais
	If Empty(::cUsername) .Or. Empty(::cPassword)
		::cLastError := "Credenciais não definidas. Use SetCredentials()"
		Return .F.
	EndIf

	// Cria Basic Auth
	cCredentials := ::cUsername + ":" + ::cPassword
	cBasicAuth := "Basic " + Encode64(cCredentials)

	// Cria cliente REST (apenas host)
	oRestClient := FWRest():New(AllTrim(::cUrl))
	oRestClient:SetPath("/api/security/token?grant_type=password&issuer=TOTVS-ADVPL-FWJWT")

	// Define timeout (método oficial)
	oRestClient:SetTimeOut(::nTimeout)

	// Desabilita checagem automática de status para controlar manualmente
	oRestClient:SetChkStatus(.F.)

	// Prepara headers
	aAdd(aHeader, "Content-Type: application/json")
	aAdd(aHeader, "Authorization: " + cBasicAuth)

	// Monta JSON body
	cJsonBody := '{"rememberUser":' + If(lRememberUser, "true", "false") + '}'

	// Define body da requisição
	oRestClient:SetPostParams(cJsonBody)

	// Envia requisição POST
	If oRestClient:Post(aHeader)
		cResponse := oRestClient:GetResult()

		If !Empty(cResponse)
			// Parse JSON response
			oJson := JsonObject():New()

			If oJson:FromJson(cResponse) == Nil
				// Busca o token no response
				If oJson:HasProperty("access_token")
					::SetToken(oJson["access_token"])
					lSuccess := .T.
				ElseIf oJson:HasProperty("token")
					::SetToken(oJson["token"])
					lSuccess := .T.
				Else
					::cLastError := "Token não encontrado na resposta"
				EndIf
			Else
				::cLastError := "Erro ao processar JSON de resposta"
			EndIf

			FreeObj(oJson)
		Else
			::cLastError := "Resposta vazia do servidor"
		EndIf
	Else
		::cLastError := "Erro na autenticação: " + oRestClient:GetLastError()
		If !Empty(oRestClient:GetResult())
			::cLastError += " - " + oRestClient:GetResult()
		EndIf
	EndIf

Return lSuccess

//-------------------------------------------------------------------
/*/{Protheus.doc} SetToken
Define o token de autorização Bearer
@type method
@param cToken, character, Token JWT
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetToken(cToken As Character) As Logical Class clPrintSmartView
	Local nPos As Numeric

	::cToken := cToken

	// Salva token no parâmetro se habilitado
	If ::lUseParamCache
		PutMV("MV_PSVTOKN", cToken)
	EndIf

	// Remove header Authorization existente
	nPos := aScan(::aHeaders, {|x| Upper(x[1]) == "AUTHORIZATION"})
	If nPos > 0
		aDel(::aHeaders, nPos)
		aSize(::aHeaders, Len(::aHeaders) - 1)
	EndIf

	// Adiciona novo header
	::AddHeader("Authorization", "Bearer " + cToken)
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} EnableTokenCache
Habilita/desabilita cache de token em parâmetro
@type method
@param lEnable, logical, .T. para habilitar cache em MV_PSVTOKN
@return logical, .T. sempre
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method EnableTokenCache(lEnable As Logical) As Logical Class clPrintSmartView
	Default lEnable := .T.
	::lUseParamCache := lEnable
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GetCachedToken
Tenta recuperar token do cache (parâmetro ou memória)
@type method
@return character, Token em cache ou vazio
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GetCachedToken() As Character Class clPrintSmartView
	Local cToken := ""
	
	// Tenta do parâmetro primeiro se habilitado
	If ::lUseParamCache
		cToken := SuperGetMV("MV_PSVTOKN", .F., "")
	EndIf
	
	// Se não encontrou no parâmetro, usa o da memória
	If Empty(cToken)
		cToken := ::cToken
	EndIf
	
Return cToken

//-------------------------------------------------------------------
/*/{Protheus.doc} EnsureAuthenticated
Garante que está autenticado, reautenticando se necessário
@type method
@return logical, .T. se está autenticado
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method EnsureAuthenticated() As Logical Class clPrintSmartView
	Local lAuthenticated := .F.
	Local cCachedToken := ""
	
	// Verifica se já tem token em cache
	cCachedToken := ::GetCachedToken()
	
	If !Empty(cCachedToken)
		// Usa token do cache
		::SetToken(cCachedToken)
		lAuthenticated := .T.
	Else
		// Tenta autenticar se tem credenciais
		If !Empty(::cUsername) .And. !Empty(::cPassword)
			lAuthenticated := ::Authenticate(.F.)
		Else
			::cLastError := "Token não encontrado e credenciais não definidas"
			lAuthenticated := .F.
		EndIf
	EndIf
	
Return lAuthenticated

//-------------------------------------------------------------------
/*/{Protheus.doc} SetReportId
Define o ID do relatório SmartView
@type method
@param cReportId, character, UUID do relatório
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetReportId(cReportId As Character) As Logical Class clPrintSmartView
	::cReportId := cReportId
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SetGenerationId
Define o ID de geração do relatório (retornado após gerar)
@type method
@param cGenerationId, character, UUID da geração
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetGenerationId(cGenerationId As Character) As Logical Class clPrintSmartView
	::cGenerationId := cGenerationId
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GenerateReport
Gera relatório SmartView com parâmetros e formatos
@type method
@param aParameters, array, Array com parâmetros [{"key","value"}]
@param aFormats, array, Array com formatos ["pdf","xlsx"]
@param lSaveFile, logical, .T. para salvar arquivo
@param cFileName, character, Nome do arquivo
@return variant, Caminho do arquivo ou base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GenerateReport(aParameters As Array, aFormats As Array, lSaveFile As Logical, cFileName As Character) As Variant Class clPrintSmartView
	Local cJson As Character
	Local cParams As Character
	Local cResponse As Character
	Local oJson As Object
	Local cGenerationId As Character
	Local nI As Numeric
	Local xReturn As Variant

	Default aParameters := {}
	Default aFormats := {"pdf"}
	Default lSaveFile := .T.
	Default cFileName := "report_" + DtoS(Date()) + "_" + StrTran(Time(), ":", "") + "." + aFormats[1]

	// Garante autenticação antes de gerar relatório
	If !::EnsureAuthenticated()
		Return Nil
	EndIf

	// Valida dados obrigatórios
	If Empty(::cReportId)
		::cLastError := "Report ID não definido. Use SetReportId()"
		Return Nil
	EndIf

	// Monta JSON de parâmetros
	cParams := ""
	If Len(aParameters) > 0
		For nI := 1 To Len(aParameters)
			If nI > 1
				cParams += ","
			EndIf
			// Monta o valor conforme o tipo
			cParams += '"' + aParameters[nI][1] + '":'
			If ValType(aParameters[nI][2]) == "C"
				cParams += '"' + aParameters[nI][2] + '"'
			ElseIf ValType(aParameters[nI][2]) == "N"
				cParams += cValToChar(aParameters[nI][2])
			ElseIf ValType(aParameters[nI][2]) == "L"
				cParams += If(aParameters[nI][2], "true", "false")
			Else
				// Array ou Object, assume que já vem como string JSON
				cParams += aParameters[nI][2]
			EndIf
		Next nI
	EndIf

	// Monta JSON completo
	cJson := '{'
	cJson += '"reportId":"' + ::cReportId + '"'

	If !Empty(cParams)
		cJson += ',"parameters":{' + cParams + '}'
	EndIf

	cJson += ',"exportFormats":['
	For nI := 1 To Len(aFormats)
		If nI > 1
			cJson += ','
		EndIf
		cJson += '"' + aFormats[nI] + '"'
	Next nI
	cJson += ']'
	cJson += '}'

	// Envia POST para iniciar geração (retorna JSON com generationId ou string direta)
	cResponse := ::PostRequest(cJson)
	
	If Empty(cResponse)
		::cLastError := "Erro ao iniciar geração do relatório"
		Return Nil
	EndIf
	
	// Remove aspas se vier como string JSON simples: "uuid"
	cGenerationId := AllTrim(cResponse)
	If Left(cGenerationId, 1) == '"' .And. Right(cGenerationId, 1) == '"'
		cGenerationId := SubStr(cGenerationId, 2, Len(cGenerationId) - 2)
		::SetGenerationId(cGenerationId)
	Else
		// Tenta parse como objeto JSON
		oJson := JsonObject():New()
		If oJson:FromJson(cResponse) == Nil
			// Extrai generationId do objeto
			If oJson:HasProperty("generationId")
				cGenerationId := oJson["generationId"]
				::SetGenerationId(cGenerationId)
			ElseIf oJson:HasProperty("id")
				cGenerationId := oJson["id"]
				::SetGenerationId(cGenerationId)
			Else
				::cLastError := "generationId não encontrado na resposta: " + cResponse
				FreeObj(oJson)
				Return Nil
			EndIf
			FreeObj(oJson)
		Else
			// Não é JSON válido nem string com aspas - assume que é o ID direto
			::SetGenerationId(cGenerationId)
		EndIf
	EndIf
	
	// Aguarda o relatório ficar pronto e então baixa
	xReturn := ::WaitAndDownloadReport(aFormats[1], lSaveFile, cFileName)
	
Return xReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} CheckReportStatus
Verifica o status de geração do relatório
@type method
@return character, Status do relatório (Completed, Pending, Error, etc)
@author Lucas Souza - Insider Consulting
@since 04/12/2025
/*/
//-------------------------------------------------------------------
Method CheckReportStatus() As Character Class clPrintSmartView
	Local oRestClient As Object
	Local cResponse As Character
	Local oJson As Object
	Local cStatus As Character
	Local cHost As Character
	Local cPath As Character
	Local aHeader As Array
	Local nI As Numeric
	
	cStatus := ""
	::cLastError := ""
	
	// Valida generationId
	If Empty(::cGenerationId)
		::cLastError := "Generation ID não definido"
		Return ""
	EndIf
	
	// Monta endpoint para consultar status
	cHost := AllTrim(::cUrl)
	cPath := "/api/reports/v2/generate/" + ::cGenerationId
	
	// Cria cliente REST
	oRestClient := FWRest():New(cHost)
	oRestClient:SetPath(cPath)
	oRestClient:SetTimeOut(::nTimeout)
	oRestClient:SetChkStatus(.F.)
	
	// Prepara headers
	aHeader := {}
	For nI := 1 To Len(::aHeaders)
		aAdd(aHeader, ::aHeaders[nI][1] + ": " + ::aHeaders[nI][2])
	Next nI
	
	// Envia requisição GET
	If oRestClient:Get(aHeader)
		cResponse := oRestClient:GetResult()
		
		If !Empty(cResponse)
			oJson := JsonObject():New()
			If oJson:FromJson(cResponse) == Nil
				If oJson:HasProperty("status")
					cStatus := oJson["status"]
				EndIf
			EndIf
			FreeObj(oJson)
		EndIf
	Else
		::cLastError := "Erro ao consultar status: " + oRestClient:GetLastError()
	EndIf
	
Return cStatus

//-------------------------------------------------------------------
/*/{Protheus.doc} WaitAndDownloadReport
Aguarda relatório ficar pronto e faz download
@type method
@param cFormat, character, Formato do arquivo (pdf, xlsx, etc)
@param lSaveFile, logical, .T. para salvar arquivo
@param cFileName, character, Nome do arquivo
@return variant, Caminho do arquivo ou base64
@author Lucas Souza - Insider Consulting
@since 04/12/2025
/*/
//-------------------------------------------------------------------
Method WaitAndDownloadReport(cFormat As Character, lSaveFile As Logical, cFileName As Character) As Variant Class clPrintSmartView
	Local cStatus As Character
	Local nTentativas As Numeric
	Local nMaxTentativas As Numeric
	Local nIntervalo As Numeric
	Local xReturn As Variant
	
	Default cFormat := "pdf"
	Default lSaveFile := .T.
	Default cFileName := "report_" + DtoS(Date()) + "_" + StrTran(Time(), ":", "") + "." + cFormat
	
	nMaxTentativas := 10
	nIntervalo := 5 // segundos
	nTentativas := 0
	cStatus := ""
	
	// Loop de verificação de status
	While nTentativas < nMaxTentativas
		nTentativas++
		
		// Consulta status
		cStatus := ::CheckReportStatus()
		
		If Empty(cStatus)
			::cLastError := "Erro ao verificar status do relatório"
			Return Nil
		EndIf
		
		// Verifica se completou
		If Upper(AllTrim(cStatus)) == "COMPLETED"
			ConOut("[SmartView] Relatório pronto após " + cValToChar(nTentativas) + " tentativa(s)")
			Exit
		ElseIf Upper(AllTrim(cStatus)) == "ERROR" .Or. Upper(AllTrim(cStatus)) == "FAILED"
			::cLastError := "Geração do relatório falhou com status: " + cStatus
			Return Nil
		EndIf
		
		// Se ainda está pendente, aguarda
		If nTentativas < nMaxTentativas
			ConOut("[SmartView] Aguardando geração... Status: " + cStatus + " (tentativa " + cValToChar(nTentativas) + "/" + cValToChar(nMaxTentativas) + ")")
			Sleep(nIntervalo * 1000) // Converte para milissegundos
		EndIf
	End
	
	// Verifica se deu timeout
	If Upper(AllTrim(cStatus)) != "COMPLETED"
		::cLastError := "Timeout ao aguardar geração do relatório. Última verificação: " + cStatus
		Return Nil
	EndIf
	
	// Baixa o relatório
	xReturn := ::DownloadReport(cFormat, lSaveFile, cFileName)
	
Return xReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} DownloadReport
Baixa relatório já gerado usando generation ID
@type method
@param cFormat, character, Formato do arquivo (pdf, xlsx, etc)
@param lSaveFile, logical, .T. para salvar arquivo
@param cFileName, character, Nome do arquivo
@return variant, Caminho do arquivo ou base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method DownloadReport(cFormat As Character, lSaveFile As Logical, cFileName As Character) As Variant Class clPrintSmartView
	Local cEndpointBackup As Character
	Local xReturn As Variant

	Default cFormat := "pdf"
	Default lSaveFile := .T.
	Default cFileName := "report_" + DtoS(Date()) + "_" + StrTran(Time(), ":", "") + "." + cFormat

	// Valida dados obrigatórios
	If Empty(::cGenerationId)
		::cLastError := "Generation ID não definido. Use SetGenerationId() ou gere um relatório primeiro"
		Return Nil
	EndIf

	// Salva endpoint atual e define novo para download
	cEndpointBackup := ::cEndpoint
	::cEndpoint := "/api/reports/v2/generate/" + ::cGenerationId + "/" + cFormat

	// Faz requisição GET
	xReturn := ::GetRequest(lSaveFile, cFileName)

	// Restaura endpoint original
	::cEndpoint := cEndpointBackup

Return xReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} GetRequest
Envia requisição GET e retorna o conteúdo
@type method
@param lSaveFile, logical, .T. para salvar arquivo
@param cFileName, character, Nome do arquivo
@return variant, Caminho do arquivo ou base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GetRequest(lSaveFile As Logical, cFileName As Character) As Variant Class clPrintSmartView
	Local oRestClient As Object
	Local cResponse := ""
	Local cHost := ""
	Local cPath := ""
	Local aHeader As Array
	Local xReturn := Nil
	Local nI As Numeric

	Default lSaveFile := .T.
	Default cFileName := "file_" + DtoS(Date()) + "_" + StrTran(Time(), ":", "") + ".dat"

	::cLastError := ""

	// Separa host e path conforme documentação FWRest
	cHost := AllTrim(::cUrl)
	cPath := AllTrim(::cEndpoint)

	// Cria cliente REST (apenas host)
	oRestClient := FWRest():New(cHost)
	oRestClient:SetPath(cPath)

	// Define timeout usando método oficial
	oRestClient:SetTimeOut(::nTimeout)

	// Desabilita checagem automática de status para controlar manualmente
	oRestClient:SetChkStatus(.F.)

	// Prepara headers no formato correto
	aHeader := {}
	For nI := 1 To Len(::aHeaders)
		aAdd(aHeader, ::aHeaders[nI][1] + ": " + ::aHeaders[nI][2])
	Next nI

	// Envia requisição GET
	If oRestClient:Get(aHeader)
		cResponse := oRestClient:GetResult()

		// Verifica se o retorno é um arquivo (binário ou texto)
		If !Empty(cResponse)
			If lSaveFile
				// Salva arquivo na pasta temporária
				xReturn := ::SaveToTemp(cResponse, cFileName)
			Else
				// Converte para base64
				xReturn := ::ConvertToBase64(cResponse)
			EndIf
		Else
			::cLastError := "Resposta vazia do servidor"
		EndIf
	Else
		::cLastError := "Erro na requisição: " + oRestClient:GetLastError()
		If !Empty(oRestClient:GetResult())
			::cLastError += " - " + oRestClient:GetResult()
		EndIf
	EndIf

Return xReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} PostRequest
Envia requisição POST e retorna a resposta JSON
@type method
@param cJsonBody, character, JSON para enviar no body
@return variant, Resposta JSON do servidor ou Nil em caso de erro
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method PostRequest(cJsonBody As Character) As Variant Class clPrintSmartView
	Local oRestClient As Object
	Local cResponse := ""
	Local cHost := ""
	Local cPath := ""
	Local aHeader As Array
	Local nI As Numeric

	::cLastError := ""

	// Separa host e path conforme documentação FWRest
	cHost := AllTrim(::cUrl)
	cPath := AllTrim(::cEndpoint)

	// Cria cliente REST (apenas host)
	oRestClient := FWRest():New(cHost)
	oRestClient:SetPath(cPath)

	// Define timeout usando método oficial
	oRestClient:SetTimeOut(::nTimeout)

	// Desabilita checagem automática de status para controlar manualmente
	oRestClient:SetChkStatus(.F.)

	// Prepara headers no formato correto
	aHeader := {}
	For nI := 1 To Len(::aHeaders)
		aAdd(aHeader, ::aHeaders[nI][1] + ": " + ::aHeaders[nI][2])
	Next nI

	// Define body da requisição
	oRestClient:SetPostParams(cJsonBody)

	// Envia requisição POST
	If oRestClient:Post(aHeader)
		cResponse := oRestClient:GetResult()
		
		If Empty(cResponse)
			::cLastError := "Resposta vazia do servidor"
		EndIf
	Else
		::cLastError := "Erro na requisição: " + oRestClient:GetLastError()
		If !Empty(oRestClient:GetResult())
			::cLastError += " - " + oRestClient:GetResult()
		EndIf
	EndIf

Return cResponse

//-------------------------------------------------------------------
/*/{Protheus.doc} GetLastError
Retorna o último erro ocorrido
@type method
@return character, Mensagem de erro
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GetLastError() As Character Class clPrintSmartView
Return ::cLastError

//-------------------------------------------------------------------
/*/{Protheus.doc} SaveToTemp
Salva conteúdo em arquivo na pasta temporária
@type method
@param cContent, character, Conteúdo do arquivo
@param cFileName, character, Nome do arquivo
@return character, Caminho completo do arquivo salvo
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SaveToTemp(cContent As Character, cFileName As Character) As Character Class clPrintSmartView
	Local cFilePath := ""
	Local nHandle As Numeric
	Local lSuccess := .F.

	// Garante que o caminho temporário termina com barra
	If Right(::cTempPath, 1) != "\"
		::cTempPath += "\"
	EndIf

	cFilePath := ::cTempPath + cFileName

	// Cria/sobrescreve arquivo
	nHandle := FCreate(cFilePath)

	If nHandle >= 0
		If FWrite(nHandle, cContent) == Len(cContent)
			lSuccess := .T.
		Else
			::cLastError := "Erro ao gravar arquivo: " + cFilePath
		EndIf
		FClose(nHandle)
	Else
		::cLastError := "Erro ao criar arquivo: " + cFilePath + " - FError: " + cValToChar(FError())
	EndIf

	If !lSuccess
		cFilePath := ""
	EndIf

Return cFilePath

//-------------------------------------------------------------------
/*/{Protheus.doc} ConvertToBase64
Converte conteúdo para base64
@type method
@param cContent, character, Conteúdo a ser convertido
@return character, String em base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method ConvertToBase64(cContent As Character) As Character Class clPrintSmartView
	Local cBase64 := ""

	If !Empty(cContent)
		cBase64 := Encode64(cContent)
	Else
		::cLastError := "Conteúdo vazio para conversão base64"
	EndIf

Return cBase64

//-------------------------------------------------------------------
/*/{Protheus.doc} FileToBase64
Lê arquivo e converte para base64
@type method
@param cFilePath, character, Caminho do arquivo
@return character, String em base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method FileToBase64(cFilePath As Character) As Character Class clPrintSmartView
	Local cContent := ""
	Local cBase64 := ""
	Local nHandle As Numeric
	Local nSize As Numeric

	If File(cFilePath)
		nHandle := FOpen(cFilePath, 0) // Modo leitura

		If nHandle >= 0
			nSize := FSeek(nHandle, 0, 2) // Vai para o final
			FSeek(nHandle, 0, 0) // Volta para o início

			cContent := Space(nSize)
			FRead(nHandle, @cContent, nSize)
			FClose(nHandle)

			cBase64 := ::ConvertToBase64(cContent)
		Else
			::cLastError := "Erro ao abrir arquivo: " + cFilePath + " - FError: " + cValToChar(FError())
		EndIf
	Else
		::cLastError := "Arquivo não encontrado: " + cFilePath
	EndIf

Return cBase64

//-------------------------------------------------------------------
/*/{Protheus.doc} SendFileAsBase64
Envia novo POST com arquivo convertido em base64
@type method
@param cJsonBody, character, Template JSON (deve conter {BASE64} para substituição)
@param cFilePath, character, Caminho do arquivo
@return character, Resposta do servidor
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SendFileAsBase64(cJsonBody As Character, cFilePath As Character) As Character Class clPrintSmartView
	Local cBase64 := ""
	Local cJsonToSend := ""
	Local oRestClient As Object
	Local cResponse := ""
	Local cHost := ""
	Local cPath := ""
	Local aHeader As Array
	Local nI As Numeric

	::cLastError := ""

	// Converte arquivo para base64
	cBase64 := ::FileToBase64(cFilePath)

	If Empty(cBase64)
		Return ""
	EndIf

	// Substitui placeholder no JSON
	cJsonToSend := StrTran(cJsonBody, "{BASE64}", cBase64)

	// Separa host e path conforme documentação FWRest
	cHost := AllTrim(::cUrl)
	cPath := AllTrim(::cEndpoint)

	// Cria cliente REST (apenas host)
	oRestClient := FWRest():New(cHost)
	oRestClient:SetPath(cPath)

	// Define timeout usando método oficial
	oRestClient:SetTimeOut(::nTimeout)

	// Desabilita checagem automática de status para controlar manualmente
	oRestClient:SetChkStatus(.F.)

	// Prepara headers no formato correto
	aHeader := {}
	For nI := 1 To Len(::aHeaders)
		aAdd(aHeader, ::aHeaders[nI][1] + ": " + ::aHeaders[nI][2])
	Next nI

	// Define body da requisição
	oRestClient:SetPostParams(cJsonToSend)

	// Envia requisição POST
	If oRestClient:Post(aHeader)
		cResponse := oRestClient:GetResult()
	Else
		::cLastError := "Erro na requisição: " + oRestClient:GetLastError()
		If !Empty(oRestClient:GetResult())
			::cLastError += " - " + oRestClient:GetResult()
		EndIf
	EndIf

Return cResponse

//-------------------------------------------------------------------
/*/{Protheus.doc} U_PSVTEST
Função de teste da classe clPrintSmartView
@type function
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
User Function PSVTEST() 
	Local oReport As Object
	Local cResult As Character
	Local aParams As Array

	// Exemplo 0: Autenticação automática com cache em parâmetro
	ConOut("[TEST] Iniciando teste da classe clPrintSmartView")
	
	oReport := clPrintSmartView():New()

	ConOut("[TEST] Configurando relatório")
	oReport:SetReportId("dae9a9a2-a6d8-43ef-ba95-3af02b7623e9")

	// Define parâmetros do relatório conforme API SmartView
	ConOut("[TEST] Preparando parâmetros do relatório")
	aParams := {}
	aAdd(aParams, {"SV_MULTBRANCH", "[]"})
	aAdd(aParams, {"MV_PAR01", "   "})
	aAdd(aParams, {"MV_PAR02", "ZZZ"})
	aAdd(aParams, {"MV_PAR03", 1})
	aAdd(aParams, {"MV_PAR04", 1})

	// Gera relatório - autenticação automática
	ConOut("[TEST] Gerando relatório (autenticação automática)")
	cResult := oReport:GenerateReport(aParams, {"pdf"}, .T., "relatorio_smartview.pdf")

	If !Empty(cResult)
		ConOut("[TEST] Sucesso! Relatório gerado: " + cResult)
		FWAlertSuccess("Relatório gerado e salvo em: " + cResult, "Sucesso")
	Else
		ConOut("[TEST] ERRO: " + oReport:GetLastError())
		FWAlertError("Erro ao gerar relatório: " + oReport:GetLastError(), "Erro na Geração")
	EndIf

	ConOut("[TEST] Teste concluído")

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} U_PSVPROD
Exemplo de uso em produção com cache de token em parâmetro
@type function
@author Lucas Souza - Insider Consulting
@since 28/11/2025
@obs Para usar, configure os parâmetros MV_PSVUSER e MV_PSVPASS
/*/
//-------------------------------------------------------------------
User Function PSVPROD() 
	Local oReport As Object
	Local cResult As Character
	Local aParams As Array
	
	ConOut("[PROD] Iniciando geração de relatório em produção")
	
	// Cria instância e configura
	oReport := clPrintSmartView():New()
	
	// Configura relatório
	oReport:SetReportId("dae9a9a2-a6d8-43ef-ba95-3af02b7623e9")
	
	// Parâmetros do relatório
	aParams := {}
	aAdd(aParams, {"SV_MULTBRANCH", "[]"})
	aAdd(aParams, {"MV_PAR01", "   "})
	aAdd(aParams, {"MV_PAR02", "ZZZ"})
	aAdd(aParams, {"MV_PAR03", 1})
	aAdd(aParams, {"MV_PAR04", 1})
	
	// Gera relatório - autenticação automática com cache
	ConOut("[PROD] Gerando relatório (cache em parâmetro MV_PSVTOKN)")
	cResult := oReport:GenerateReport(aParams, {"pdf"}, .T., "relatorio_producao.pdf")
	
	If !Empty(cResult)
		ConOut("[PROD] Sucesso! Relatório: " + cResult)
		MsgInfo("Relatório gerado com sucesso!" + CRLF + cResult, "Produção")
	Else
		ConOut("[PROD] ERRO: " + oReport:GetLastError())
		MsgStop("Erro ao gerar relatório: " + CRLF + oReport:GetLastError(), "Erro")
	EndIf
	
Return !Empty(cResult)

