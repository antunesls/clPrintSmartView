#Include 'totvs.ch'
#Include "tlpp-core.th"
#Include "tlpp-rest.th"

//-------------------------------------------------------------------
// Namespace
//-------------------------------------------------------------------
Namespace PrintSmartView

//-------------------------------------------------------------------
/*/{Protheus.doc} clPrintSmartView
Classe para geração e download de relatórios SmartView de forma automatizada.
Permite gerar relatórios sem interface gráfica, ideal para uso em:
- Jobs programados
- Schedules
- Envio automático para impressoras
- Processamentos em background
- Integração com APIs
@type class
@author Lucas Souza - Insider Consulting
@since 28/11/2025
@version 1.0
@example
// Exemplo de uso em Job
oReport := clPrintSmartView():New()
oReport:SetUrl("http://localhost:7017")
oReport:SetCredentials("admin", "admin")
If oReport:Authenticate(.F.)
    oReport:SetReportId("uuid-do-relatorio")
    oReport:SetEndpoint("/api/reports/v2/generate")
    cArquivo := oReport:GenerateReport({{"param1","valor"}}, {"pdf"}, .T.)
EndIf
/*/
//-------------------------------------------------------------------
Class clPrintSmartView

	// Propriedades públicas
	Public Data cEndpoint As Character
	Public Data aHeaders As Array
	Public Data cLastError As Character
	Public Data cTempPath As Character
	Public Data nTimeout As Numeric
	Public Data cToken As Character
	Public Data cReportId As Character
	Public Data cGenerationId As Character
	
	// Propriedades privadas
	Private Data cUrl As Character
	Private Data cUsername As Character
	Private Data cPassword As Character
	Private Data lUseParamCache As Logical
	Private Data cTokenExpiry As Character
	
	// Métodos públicos
	Public Method New()
	Public Method SetUrl(cUrl As Character) As Logical
	Public Method GetUrl() As Character
	Public Method SetEndpoint(cEndpoint As Character) As Logical
	Public Method AddHeader(cKey As Character, cValue As Character) As Logical
	Public Method SetTimeout(nSeconds As Numeric) As Logical
	Public Method SetCredentials(cUsername As Character, cPassword As Character) As Logical
	Public Method GetUsername() As Character
	Public Method Authenticate(lRememberUser As Logical) As Logical
	Public Method SetToken(cToken As Character) As Logical
	Public Method EnableTokenCache(lEnable As Logical) As Logical
	Public Method GetCachedToken() As Character
	Public Method EnsureAuthenticated() As Logical
	Public Method SetReportId(cReportId As Character) As Logical
	Public Method SetGenerationId(cGenerationId As Character) As Logical
	Public Method GenerateReport(aParameters As Array, aFormats As Array, lSaveFile As Logical, cFileName As Character) As Variant
	Public Method DownloadReport(cFormat As Character, lSaveFile As Logical, cFileName As Character) As Variant
	Public Method GetRequest(lSaveFile As Logical, cFileName As Character) As Variant
	Public Method PostRequest(cJsonBody As Character, lSaveFile As Logical, cFileName As Character) As Variant
	Public Method GetLastError() As Character
	Public Method SaveToTemp(cContent As Character, cFileName As Character) As Character
	Public Method ConvertToBase64(cContent As Character) As Character
	Public Method FileToBase64(cFilePath As Character) As Character
	Public Method SendFileAsBase64(cJsonBody As Character, cFilePath As Character) As Character

EndClass

//-------------------------------------------------------------------
/*/{Protheus.doc} New
Construtor da classe
@type method
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method New() Class clPrintSmartView

	::cUrl := ""
	::cEndpoint := ""
	::aHeaders := {}
	::cLastError := ""
	::cTempPath := GetTempPath()
	::nTimeout := 120
	::cToken := ""
	::cReportId := ""
	::cGenerationId := ""
	::cUsername := ""
	::cPassword := ""
	::lUseParamCache := .F.
	::cTokenExpiry := ""

Return Self

//-------------------------------------------------------------------
/*/{Protheus.doc} SetUrl
Define a URL base para as requisições
@type method
@param cUrl, character, URL base
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetUrl(cUrl As Character) As Logical Class clPrintSmartView
	::cUrl := cUrl
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GetUrl
Retorna a URL base configurada
@type method
@return character, URL base
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GetUrl() As Character Class clPrintSmartView
Return ::cUrl

//-------------------------------------------------------------------
/*/{Protheus.doc} SetEndpoint
Define o endpoint específico
@type method
@param cEndpoint, character, Endpoint da API
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetEndpoint(cEndpoint As Character) As Logical Class clPrintSmartView
	::cEndpoint := cEndpoint
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} AddHeader
Adiciona um header à requisição
@type method
@param cKey, character, Chave do header
@param cValue, character, Valor do header
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method AddHeader(cKey As Character, cValue As Character) As Logical Class clPrintSmartView
	aAdd(::aHeaders, {cKey, cValue})
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SetTimeout
Define o timeout da requisição
@type method
@param nSeconds, numeric, Timeout em segundos
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetTimeout(nSeconds As Numeric) As Logical Class clPrintSmartView
	::nTimeout := nSeconds
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SetCredentials
Define as credenciais de usuário e senha para autenticação
@type method
@param cUsername, character, Nome de usuário
@param cPassword, character, Senha
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetCredentials(cUsername As Character, cPassword As Character) As Logical Class clPrintSmartView
	::cUsername := cUsername
	::cPassword := cPassword
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GetUsername
Retorna o nome de usuário configurado
@type method
@return character, Nome de usuário
@author Lucas Souza - Insider Consulting
@since 28/11/2025
@obs A senha não possui método Get por questões de segurança
/*/
//-------------------------------------------------------------------
Method GetUsername() As Character Class clPrintSmartView
Return ::cUsername

//-------------------------------------------------------------------
/*/{Protheus.doc} Authenticate
Realiza autenticação e obtém token JWT
@type method
@param lRememberUser, logical, Se deve lembrar o usuário
@return logical, .T. se autenticou com sucesso
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method Authenticate(lRememberUser As Logical) As Logical Class clPrintSmartView
	
	Local oRestClient As Object
	//Local cFullUrl As Character
	Local cResponse As Character
	Local cBasicAuth As Character
	Local cCredentials As Character
	Local cJsonBody As Character
	Local oJson As Object
	Local aHeader As Array
	Local lSuccess := .F.
	
	aHeader := {}

	Default lRememberUser := .F.

	::cLastError := ""

	// Valida credenciais
	If Empty(::cUsername) .Or. Empty(::cPassword)
		::cLastError := "Credenciais não definidas. Use SetCredentials()"
		Return .F.
	EndIf

	// Cria Basic Auth
	cCredentials := ::cUsername + ":" + ::cPassword
	cBasicAuth := "Basic " + Encode64(cCredentials)

	// Cria cliente REST (apenas host)
	oRestClient := FWRest():New(AllTrim(::cUrl))
	oRestClient:SetPath("/api/security/token?grant_type=password&issuer=TOTVS-ADVPL-FWJWT")

	// Define timeout (método oficial)
	oRestClient:SetTimeOut(::nTimeout)

	// Desabilita checagem automática de status para controlar manualmente
	oRestClient:SetChkStatus(.F.)

	// Prepara headers
	aAdd(aHeader, "Content-Type: application/json")
	aAdd(aHeader, "Authorization: " + cBasicAuth)

	// Monta JSON body
	cJsonBody := '{"rememberUser":' + If(lRememberUser, "true", "false") + '}'

	// Define body da requisição
	oRestClient:SetPostParams(cJsonBody)

	// Envia requisição POST
	If oRestClient:Post(aHeader)
		cResponse := oRestClient:GetResult()

		If !Empty(cResponse)
			// Parse JSON response
			oJson := JsonObject():New()

			If oJson:FromJson(cResponse) == Nil
				// Busca o token no response
				If oJson:HasProperty("access_token")
					::SetToken(oJson["access_token"])
					lSuccess := .T.
				ElseIf oJson:HasProperty("token")
					::SetToken(oJson["token"])
					lSuccess := .T.
				Else
					::cLastError := "Token não encontrado na resposta"
				EndIf
			Else
				::cLastError := "Erro ao processar JSON de resposta"
			EndIf

			FreeObj(oJson)
		Else
			::cLastError := "Resposta vazia do servidor"
		EndIf
	Else
		::cLastError := "Erro na autenticação: " + oRestClient:GetLastError()
		If !Empty(oRestClient:GetResult())
			::cLastError += " - " + oRestClient:GetResult()
		EndIf
	EndIf

Return lSuccess

//-------------------------------------------------------------------
/*/{Protheus.doc} SetToken
Define o token de autorização Bearer
@type method
@param cToken, character, Token JWT
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetToken(cToken As Character) As Logical Class clPrintSmartView
	Local nPos As Numeric

	::cToken := cToken

	// Salva token no parâmetro se habilitado
	If ::lUseParamCache
		PutMV("MV_PSVTOKN", cToken)
	EndIf

	// Remove header Authorization existente
	nPos := aScan(::aHeaders, {|x| Upper(x[1]) == "AUTHORIZATION"})
	If nPos > 0
		aDel(::aHeaders, nPos)
		aSize(::aHeaders, Len(::aHeaders) - 1)
	EndIf

	// Adiciona novo header
	::AddHeader("Authorization", "Bearer " + cToken)
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} EnableTokenCache
Habilita/desabilita cache de token em parâmetro
@type method
@param lEnable, logical, .T. para habilitar cache em MV_PSVTOKN
@return logical, .T. sempre
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method EnableTokenCache(lEnable As Logical) As Logical Class clPrintSmartView
	Default lEnable := .T.
	::lUseParamCache := lEnable
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GetCachedToken
Tenta recuperar token do cache (parâmetro ou memória)
@type method
@return character, Token em cache ou vazio
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GetCachedToken() As Character Class clPrintSmartView
	Local cToken := ""
	
	// Tenta do parâmetro primeiro se habilitado
	If ::lUseParamCache
		cToken := SuperGetMV("MV_PSVTOKN", .F., "")
	EndIf
	
	// Se não encontrou no parâmetro, usa o da memória
	If Empty(cToken)
		cToken := ::cToken
	EndIf
	
Return cToken

//-------------------------------------------------------------------
/*/{Protheus.doc} EnsureAuthenticated
Garante que está autenticado, reautenticando se necessário
@type method
@return logical, .T. se está autenticado
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method EnsureAuthenticated() As Logical Class clPrintSmartView
	Local lAuthenticated := .F.
	Local cCachedToken := ""
	
	// Verifica se já tem token em cache
	cCachedToken := ::GetCachedToken()
	
	If !Empty(cCachedToken)
		// Usa token do cache
		::SetToken(cCachedToken)
		lAuthenticated := .T.
	Else
		// Tenta autenticar se tem credenciais
		If !Empty(::cUsername) .And. !Empty(::cPassword)
			lAuthenticated := ::Authenticate(.F.)
		Else
			::cLastError := "Token não encontrado e credenciais não definidas"
			lAuthenticated := .F.
		EndIf
	EndIf
	
Return lAuthenticated

//-------------------------------------------------------------------
/*/{Protheus.doc} SetReportId
Define o ID do relatório SmartView
@type method
@param cReportId, character, UUID do relatório
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetReportId(cReportId As Character) As Logical Class clPrintSmartView
	::cReportId := cReportId
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} SetGenerationId
Define o ID de geração do relatório (retornado após gerar)
@type method
@param cGenerationId, character, UUID da geração
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SetGenerationId(cGenerationId As Character) As Logical Class clPrintSmartView
	::cGenerationId := cGenerationId
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GenerateReport
Gera relatório SmartView com parâmetros e formatos
@type method
@param aParameters, array, Array com parâmetros [{"key","value"}]
@param aFormats, array, Array com formatos ["pdf","xlsx"]
@param lSaveFile, logical, .T. para salvar arquivo
@param cFileName, character, Nome do arquivo
@return variant, Caminho do arquivo ou base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GenerateReport(aParameters As Array, aFormats As Array, lSaveFile As Logical, cFileName As Character) As Variant Class clPrintSmartView
	Local cJson As Character
	Local cParams As Character
	Local nI As Numeric

	Default aParameters := {}
	Default aFormats := {"pdf"}
	Default lSaveFile := .T.
	Default cFileName := "report_" + DtoS(Date()) + "_" + StrTran(Time(), ":", "") + "." + aFormats[1]

	// Garante autenticação antes de gerar relatório
	If !::EnsureAuthenticated()
		Return Nil
	EndIf

	// Valida dados obrigatórios
	If Empty(::cReportId)
		::cLastError := "Report ID não definido. Use SetReportId()"
		Return Nil
	EndIf

	// Monta JSON de parâmetros
	cParams := ""
	If Len(aParameters) > 0
		For nI := 1 To Len(aParameters)
			If nI > 1
				cParams += ","
			EndIf
			// Monta o valor conforme o tipo
			cParams += '"' + aParameters[nI][1] + '":'
			If ValType(aParameters[nI][2]) == "C"
				cParams += '"' + aParameters[nI][2] + '"'
			ElseIf ValType(aParameters[nI][2]) == "N"
				cParams += cValToChar(aParameters[nI][2])
			ElseIf ValType(aParameters[nI][2]) == "L"
				cParams += If(aParameters[nI][2], "true", "false")
			Else
				// Array ou Object, assume que já vem como string JSON
				cParams += aParameters[nI][2]
			EndIf
		Next nI
	EndIf

	// Monta JSON completo
	cJson := '{'
	cJson += '"reportId":"' + ::cReportId + '"'

	If !Empty(cParams)
		cJson += ',"parameters":{' + cParams + '}'
	EndIf

	cJson += ',"exportFormats":['
	For nI := 1 To Len(aFormats)
		If nI > 1
			cJson += ','
		EndIf
		cJson += '"' + aFormats[nI] + '"'
	Next nI
	cJson += ']'
	cJson += '}'

	// Envia requisição
Return ::PostRequest(cJson, lSaveFile, cFileName)

//-------------------------------------------------------------------
/*/{Protheus.doc} DownloadReport
Baixa relatório já gerado usando generation ID
@type method
@param cFormat, character, Formato do arquivo (pdf, xlsx, etc)
@param lSaveFile, logical, .T. para salvar arquivo
@param cFileName, character, Nome do arquivo
@return variant, Caminho do arquivo ou base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method DownloadReport(cFormat As Character, lSaveFile As Logical, cFileName As Character) As Variant Class clPrintSmartView
	Local cEndpointBackup As Character
	Local xReturn As Variant

	Default cFormat := "pdf"
	Default lSaveFile := .T.
	Default cFileName := "report_" + DtoS(Date()) + "_" + StrTran(Time(), ":", "") + "." + cFormat

	// Valida dados obrigatórios
	If Empty(::cGenerationId)
		::cLastError := "Generation ID não definido. Use SetGenerationId() ou gere um relatório primeiro"
		Return Nil
	EndIf

	// Salva endpoint atual e define novo para download
	cEndpointBackup := ::cEndpoint
	::cEndpoint := "/api/reports/v2/generate/" + ::cGenerationId + "/" + cFormat

	// Faz requisição GET
	xReturn := ::GetRequest(lSaveFile, cFileName)

	// Restaura endpoint original
	::cEndpoint := cEndpointBackup

Return xReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} GetRequest
Envia requisição GET e retorna o conteúdo
@type method
@param lSaveFile, logical, .T. para salvar arquivo
@param cFileName, character, Nome do arquivo
@return variant, Caminho do arquivo ou base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GetRequest(lSaveFile As Logical, cFileName As Character) As Variant Class clPrintSmartView
	Local oRestClient As Object
	Local cResponse := ""
	Local cHost := ""
	Local cPath := ""
	Local aHeader As Array
	Local xReturn := Nil
	Local nI As Numeric

	Default lSaveFile := .T.
	Default cFileName := "file_" + DtoS(Date()) + "_" + StrTran(Time(), ":", "") + ".dat"

	::cLastError := ""

	// Separa host e path conforme documentação FWRest
	cHost := AllTrim(::cUrl)
	cPath := AllTrim(::cEndpoint)

	// Cria cliente REST (apenas host)
	oRestClient := FWRest():New(cHost)
	oRestClient:SetPath(cPath)

	// Define timeout usando método oficial
	oRestClient:SetTimeOut(::nTimeout)

	// Desabilita checagem automática de status para controlar manualmente
	oRestClient:SetChkStatus(.F.)

	// Prepara headers no formato correto
	aHeader := {}
	For nI := 1 To Len(::aHeaders)
		aAdd(aHeader, ::aHeaders[nI][1] + ": " + ::aHeaders[nI][2])
	Next nI

	// Envia requisição GET
	If oRestClient:Get(aHeader)
		cResponse := oRestClient:GetResult()

		// Verifica se o retorno é um arquivo (binário ou texto)
		If !Empty(cResponse)
			If lSaveFile
				// Salva arquivo na pasta temporária
				xReturn := ::SaveToTemp(cResponse, cFileName)
			Else
				// Converte para base64
				xReturn := ::ConvertToBase64(cResponse)
			EndIf
		Else
			::cLastError := "Resposta vazia do servidor"
		EndIf
	Else
		::cLastError := "Erro na requisição: " + oRestClient:GetLastError()
		If !Empty(oRestClient:GetResult())
			::cLastError += " - " + oRestClient:GetResult()
		EndIf
	EndIf

Return xReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} PostRequest
Envia requisição POST e retorna o conteúdo
@type method
@param cJsonBody, character, JSON para enviar no body
@param lSaveFile, logical, .T. para salvar arquivo, .F. para retornar base64
@param cFileName, character, Nome do arquivo (opcional)
@return variant, Caminho do arquivo ou string base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method PostRequest(cJsonBody As Character, lSaveFile As Logical, cFileName As Character) As Variant Class clPrintSmartView
	Local oRestClient As Object
	Local cResponse := ""
	Local cHost := ""
	Local cPath := ""
	Local aHeader As Array
	Local xReturn := Nil
	Local nI As Numeric

	Default lSaveFile := .T.
	Default cFileName := "file_" + DtoS(Date()) + "_" + StrTran(Time(), ":", "") + ".dat"

	::cLastError := ""

	// Separa host e path conforme documentação FWRest
	cHost := AllTrim(::cUrl)
	cPath := AllTrim(::cEndpoint)

	// Cria cliente REST (apenas host)
	oRestClient := FWRest():New(cHost)
	oRestClient:SetPath(cPath)

	// Define timeout usando método oficial
	oRestClient:SetTimeOut(::nTimeout)

	// Desabilita checagem automática de status para controlar manualmente
	oRestClient:SetChkStatus(.F.)

	// Prepara headers no formato correto
	aHeader := {}
	For nI := 1 To Len(::aHeaders)
		aAdd(aHeader, ::aHeaders[nI][1] + ": " + ::aHeaders[nI][2])
	Next nI

	// Define body da requisição
	oRestClient:SetPostParams(cJsonBody)

	// Envia requisição POST
	If oRestClient:Post(aHeader)
		cResponse := oRestClient:GetResult()

		// Verifica se o retorno é um arquivo (binário ou texto)
		If !Empty(cResponse)
			If lSaveFile
				// Salva arquivo na pasta temporária
				xReturn := ::SaveToTemp(cResponse, cFileName)
			Else
				// Converte para base64
				xReturn := ::ConvertToBase64(cResponse)
			EndIf
		Else
			::cLastError := "Resposta vazia do servidor"
		EndIf
	Else
		::cLastError := "Erro na requisição: " + oRestClient:GetLastError()
		If !Empty(oRestClient:GetResult())
			::cLastError += " - " + oRestClient:GetResult()
		EndIf
	EndIf

Return xReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} GetLastError
Retorna o último erro ocorrido
@type method
@return character, Mensagem de erro
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method GetLastError() As Character Class clPrintSmartView
Return ::cLastError

//-------------------------------------------------------------------
/*/{Protheus.doc} SaveToTemp
Salva conteúdo em arquivo na pasta temporária
@type method
@param cContent, character, Conteúdo do arquivo
@param cFileName, character, Nome do arquivo
@return character, Caminho completo do arquivo salvo
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SaveToTemp(cContent As Character, cFileName As Character) As Character Class clPrintSmartView
	Local cFilePath := ""
	Local nHandle As Numeric
	Local lSuccess := .F.

	// Garante que o caminho temporário termina com barra
	If Right(::cTempPath, 1) != "\"
		::cTempPath += "\"
	EndIf

	cFilePath := ::cTempPath + cFileName

	// Cria/sobrescreve arquivo
	nHandle := FCreate(cFilePath)

	If nHandle >= 0
		If FWrite(nHandle, cContent) == Len(cContent)
			lSuccess := .T.
		Else
			::cLastError := "Erro ao gravar arquivo: " + cFilePath
		EndIf
		FClose(nHandle)
	Else
		::cLastError := "Erro ao criar arquivo: " + cFilePath + " - FError: " + cValToChar(FError())
	EndIf

	If !lSuccess
		cFilePath := ""
	EndIf

Return cFilePath

//-------------------------------------------------------------------
/*/{Protheus.doc} ConvertToBase64
Converte conteúdo para base64
@type method
@param cContent, character, Conteúdo a ser convertido
@return character, String em base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method ConvertToBase64(cContent As Character) As Character Class clPrintSmartView
	Local cBase64 := ""

	If !Empty(cContent)
		cBase64 := Encode64(cContent)
	Else
		::cLastError := "Conteúdo vazio para conversão base64"
	EndIf

Return cBase64

//-------------------------------------------------------------------
/*/{Protheus.doc} FileToBase64
Lê arquivo e converte para base64
@type method
@param cFilePath, character, Caminho do arquivo
@return character, String em base64
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method FileToBase64(cFilePath As Character) As Character Class clPrintSmartView
	Local cContent := ""
	Local cBase64 := ""
	Local nHandle As Numeric
	Local nSize As Numeric

	If File(cFilePath)
		nHandle := FOpen(cFilePath, 0) // Modo leitura

		If nHandle >= 0
			nSize := FSeek(nHandle, 0, 2) // Vai para o final
			FSeek(nHandle, 0, 0) // Volta para o início

			cContent := Space(nSize)
			FRead(nHandle, @cContent, nSize)
			FClose(nHandle)

			cBase64 := ::ConvertToBase64(cContent)
		Else
			::cLastError := "Erro ao abrir arquivo: " + cFilePath + " - FError: " + cValToChar(FError())
		EndIf
	Else
		::cLastError := "Arquivo não encontrado: " + cFilePath
	EndIf

Return cBase64

//-------------------------------------------------------------------
/*/{Protheus.doc} SendFileAsBase64
Envia novo POST com arquivo convertido em base64
@type method
@param cJsonBody, character, Template JSON (deve conter {BASE64} para substituição)
@param cFilePath, character, Caminho do arquivo
@return character, Resposta do servidor
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
Method SendFileAsBase64(cJsonBody As Character, cFilePath As Character) As Character Class clPrintSmartView
	Local cBase64 := ""
	Local cJsonToSend := ""
	Local oRestClient As Object
	Local cResponse := ""
	Local cHost := ""
	Local cPath := ""
	Local aHeader As Array
	Local nI As Numeric

	::cLastError := ""

	// Converte arquivo para base64
	cBase64 := ::FileToBase64(cFilePath)

	If Empty(cBase64)
		Return ""
	EndIf

	// Substitui placeholder no JSON
	cJsonToSend := StrTran(cJsonBody, "{BASE64}", cBase64)

	// Separa host e path conforme documentação FWRest
	cHost := AllTrim(::cUrl)
	cPath := AllTrim(::cEndpoint)

	// Cria cliente REST (apenas host)
	oRestClient := FWRest():New(cHost)
	oRestClient:SetPath(cPath)

	// Define timeout usando método oficial
	oRestClient:SetTimeOut(::nTimeout)

	// Desabilita checagem automática de status para controlar manualmente
	oRestClient:SetChkStatus(.F.)

	// Prepara headers no formato correto
	aHeader := {}
	For nI := 1 To Len(::aHeaders)
		aAdd(aHeader, ::aHeaders[nI][1] + ": " + ::aHeaders[nI][2])
	Next nI

	// Define body da requisição
	oRestClient:SetPostParams(cJsonToSend)

	// Envia requisição POST
	If oRestClient:Post(aHeader)
		cResponse := oRestClient:GetResult()
	Else
		::cLastError := "Erro na requisição: " + oRestClient:GetLastError()
		If !Empty(oRestClient:GetResult())
			::cLastError += " - " + oRestClient:GetResult()
		EndIf
	EndIf

Return cResponse

//-------------------------------------------------------------------
/*/{Protheus.doc} U_PSVTEST
Função de teste da classe clPrintSmartView
@type function
@author Lucas Souza - Insider Consulting
@since 28/11/2025
/*/
//-------------------------------------------------------------------
User Function PSVTEST() 
	Local oReport As Object
	Local cResult As Character
	Local aParams As Array

	// Exemplo 0: Autenticação automática com cache em memória
	ConOut("[TEST] Iniciando teste da classe clPrintSmartView")
	
	oReport := clPrintSmartView():New()
	oReport:SetUrl("http://localhost:7017")
	oReport:SetCredentials("admin", "admin")
	oReport:EnableTokenCache(.F.) // Usa cache em memória (não no parâmetro)

	ConOut("[TEST] Configurando endpoint e relatório")
	oReport:SetEndpoint("/api/reports/v2/generate")
	oReport:SetReportId("dae9a9a2-a6d8-43ef-ba95-3af02b7623e9")
	oReport:AddHeader("Content-Type", "application/json")

	// Define parâmetros do relatório conforme API SmartView
	ConOut("[TEST] Preparando parâmetros do relatório")
	aParams := {}
	aAdd(aParams, {"SV_MULTBRANCH", "[]"})
	aAdd(aParams, {"MV_PAR01", "   "})
	aAdd(aParams, {"MV_PAR02", "ZZZ"})
	aAdd(aParams, {"MV_PAR03", 1})
	aAdd(aParams, {"MV_PAR04", 1})

	// Gera relatório - autenticação automática
	ConOut("[TEST] Gerando relatório (autenticação automática)")
	cResult := oReport:GenerateReport(aParams, {"pdf"}, .T., "relatorio_smartview.pdf")

	If !Empty(cResult)
		ConOut("[TEST] Sucesso! Relatório gerado: " + cResult)
		FWAlertSuccess("Relatório gerado e salvo em: " + cResult, "Sucesso")
	Else
		ConOut("[TEST] ERRO: " + oReport:GetLastError())
		FWAlertError("Erro ao gerar relatório: " + oReport:GetLastError(), "Erro na Geração")
	EndIf

	ConOut("[TEST] Teste concluído")

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} U_PSVPROD
Exemplo de uso em produção com cache de token em parâmetro
@type function
@author Lucas Souza - Insider Consulting
@since 28/11/2025
@obs Para usar, configure os parâmetros MV_PSVUSER e MV_PSVPASS
/*/
//-------------------------------------------------------------------
User Function PSVPROD() 
	Local oReport As Object
	Local cResult As Character
	Local aParams As Array
	Local cUrl As Character
	Local cUser As Character
	Local cPass As Character
	
	ConOut("[PROD] Iniciando geração de relatório em produção")
	
	// Busca configurações de parâmetros (criar com GetSx6())
	cUrl := SuperGetMV("MV_PSVURL", .F., "http://localhost:7017")
	cUser := SuperGetMV("MV_PSVUSER", .F., "")
	cPass := SuperGetMV("MV_PSVPASS", .F., "")
	
	// Valida se tem configurações
	If Empty(cUser) .Or. Empty(cPass)
		ConOut("[PROD] ERRO: Parâmetros MV_PSVUSER e MV_PSVPASS não configurados!")
		MsgStop("Configure os parâmetros MV_PSVUSER e MV_PSVPASS", "Erro de Configuração")
		Return .F.
	EndIf
	
	// Cria instância e configura
	oReport := clPrintSmartView():New()
	oReport:SetUrl(cUrl)
	oReport:SetCredentials(cUser, cPass)
	oReport:EnableTokenCache(.T.) // Habilita cache em MV_PSVTOKN
	
	// Configura relatório
	oReport:SetEndpoint("/api/reports/v2/generate")
	oReport:SetReportId("dae9a9a2-a6d8-43ef-ba95-3af02b7623e9")
	oReport:AddHeader("Content-Type", "application/json")
	
	// Parâmetros do relatório
	aParams := {}
	aAdd(aParams, {"SV_MULTBRANCH", "[]"})
	aAdd(aParams, {"MV_PAR01", "   "})
	aAdd(aParams, {"MV_PAR02", "ZZZ"})
	aAdd(aParams, {"MV_PAR03", 1})
	aAdd(aParams, {"MV_PAR04", 1})
	
	// Gera relatório - autenticação automática com cache
	ConOut("[PROD] Gerando relatório (cache em parâmetro MV_PSVTOKN)")
	cResult := oReport:GenerateReport(aParams, {"pdf"}, .T., "relatorio_producao.pdf")
	
	If !Empty(cResult)
		ConOut("[PROD] Sucesso! Relatório: " + cResult)
		MsgInfo("Relatório gerado com sucesso!" + CRLF + cResult, "Produção")
	Else
		ConOut("[PROD] ERRO: " + oReport:GetLastError())
		MsgStop("Erro ao gerar relatório: " + CRLF + oReport:GetLastError(), "Erro")
	EndIf
	
Return !Empty(cResult)

